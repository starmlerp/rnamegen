#include <cstdio>
#include <cstdlib> 
#include <ctime>
#include <cmath>
#include <climits>
#include <thread>

#include "rnamegen.h"

#define SEPARATOR ','
#define NAMEDEF "/etc/rnamegen/names.csv"

size_t loadcsv(FILE* f, char ***values){
	rewind(f);
	int inp, n = 1;
	enum{
		SEEK, // searching through the word for the comma
		SPAC  // searching through the spaces for the start of the word
	}state = SPAC;
	//obtaining an calculating the size of the file
	fseek(f, 0, SEEK_END);
	size_t fsize = ftell(f);
	fseek(f, 0, SEEK_SET);
	fsize -= ftell(f);
	char *buffer = new char[fsize];
	for(size_t i = 0; i < fsize; i++)
		if((buffer[i] = fgetc(f)) == ',')n++; // increment N if we come by a comma
	*values = new char*[n];
	size_t ival = 0;
	for(size_t i = 0; i < fsize; i++){
		switch(state){
			case SEEK:
				if(buffer[i] == ',' || buffer[i] == '\n'){
					state = SPAC;
					buffer[i] = '\0';
				}
			break;
			case SPAC:
				if(buffer[i] != ' ' && buffer[i] != '\n'){
					//NOTE: this may break if multiple immediatelly successive commas are present
					state = SEEK;
					(*values)[ival++] = &buffer[i];
				}
			break;
		}
	}
	return n;
}

void assembler_thread(stats *data, stats *curdata, char **names, size_t count, double *grade){ // i think im starting to understand peas frustration with pointers
											       // this is just obnoxious
	for(size_t i = 0; i < count; i++){
		names[i] = curdata->assemble();
		grade[i] = data->evaluate(names[i]);
	}
	return;
}

//TODO: implement functions to load and save letter data in a file, as well as reimplement the analyzer function in order to make it possible for it to take the existing letter data, and append to it
int main(int argc, char *argv[]){
	stats data, *curdata = &data;
	//default values, modified by the user
	size_t count = 1;
	size_t generations = 0;
	size_t gensize = 10000;
	size_t filter = 1000;
	size_t threads = 1;
	bool append_to_base = false;
	
	if(argc > 1)
		for(int i = 1; i < argc; i++){
			size_t l;
			for(l = 0; argv[i][l]; ++l);
			if(l == 2 && argv[i][0] == '-'){
				switch(argv[i][1]){
					case 'j':
						if(argc == i - 1)
							if(argv[i+1][0] == '-'){
								threads = std::thread::hardware_concurrency();
								i++;
								break;
							}
							else;
						else threads = atoi(argv[++i]);
					break;
					case 'f':{ // which csv file to use for sampling names
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						FILE *f = fopen(argv[i], "r");
						if(!f){
							fprintf(stderr, "%s: error opening file %s: no such file\n", argv[0], argv[i]);
							return 1;
						}
						i++;
						char **names;
						size_t n = loadcsv(f, &names);
						fclose(f);
						curdata->analyze(names, n);
						delete [] *names;
					}
					break;
					case 'n': // number of names to produce 
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						count = atoi(argv[++i]);
					break;
					case 'i':{ // input file to use
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						FILE *f = fopen(argv[i], "r");
						if(!f){
							fprintf(stderr, "%s: error opening file %s: no such file\n", argv[0], argv[i]);
							return 1;
						}
						i++;
						char **csvalues;
						size_t n = loadcsv(f, &csvalues);
						fclose(f);

						if(n != UCHAR_MAX + 2 * UCHAR_MAX * UCHAR_MAX + 2){
							// we are expecting to read exactly char max value + 2 * charmax^2 + 2 numeric values
							// because for each character we store the weight of the
							// character itself, plus preceeding and succeeding values for each other character
							// and plus 2 to store the total word and letter count

							// loading any other amount is a sign of error!
							fprintf(stderr, "error loading the file: invalid number of values\nare you sure this is the input file generated by -o?\n");
							return 2;
						}
						size_t di = 0;
						for(size_t i = 0; i < UCHAR_MAX; i++){
							curdata->ldata[i].weight += atoi(csvalues[di++]);
								for(size_t j = 0; j < UCHAR_MAX; j++)
									curdata->ldata[i].preceede[j] += atoi(csvalues[di++]);
								for(size_t j = 0; j < UCHAR_MAX; j++)
									curdata->ldata[i].succeede[j] += atoi(csvalues[di++]);
						}
						curdata->ltotal += atoi(csvalues[di++]);
						curdata->cnames += atoi(csvalues[di++]);
						delete [] *csvalues;
					}
					break;
					case 'o':{ // output file to write to
						count = 0;
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0], argv[i]);
							return 1;
						}
						FILE *outfile = fopen(argv[++i], "w");
						for(size_t i = 0; i < UCHAR_MAX; i++){
							fprintf(outfile, "%ld,", curdata->ldata[i].weight);
							for(size_t j = 0; j < UCHAR_MAX; j++)
								fprintf(outfile, "%ld,", curdata->ldata[i].preceede[j]);
							for(size_t j = 0; j < UCHAR_MAX; j++)
								fprintf(outfile, "%ld,", curdata->ldata[i].succeede[j]);
						}
						fprintf(outfile, "%ld,%ld", curdata->ltotal, data.cnames);
					}
					break;
					case 'b': // generation batch size 
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						gensize = atoi(argv[++i]);
					break;
					case 's': // number of names to select for next gen
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						filter = atoi(argv[++i]);
					break;
					case 'g': // number of evaluative generations to produce
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0], argv[i]);
							return 1;
						}
						generations = atoi(argv[++i]);
						if(!data.cnames){
							FILE* f = fopen(NAMEDEF, "r");
							if(!f){
								fprintf(stderr, "%s: error opening file NAMEDEF: no such file\n", argv[0]);
								return 1;
							}
							char **names;
							size_t n = loadcsv(f, &names);
							fclose(f);
							data.analyze(names, n);
						}
						for(size_t i = 0; i < generations; i++){
							std::thread thread[threads];
							char **generation = new char*[gensize];
							double *grade = new double[gensize];
							size_t k;
//							printf("generating names\n");
							for(size_t j = 0; j < threads; j++)
								#define T_SEG gensize / threads
								thread[j]=std::thread(assembler_thread, &data, curdata, &generation[j * T_SEG], T_SEG, &grade[j * T_SEG]);
							for(size_t j = 0; j < threads; j++)
								thread[j].join();
							size_t min = 0;
//							printf("selecting names\n");
							for(size_t k= 0; k < filter; k++)
								if(grade[k] < grade[min])min = k;
							for(size_t j = filter; j < gensize; j++){
								if(grade[j] > grade[min]){
									delete [] generation[min];
									grade[min] = grade[j];
									generation[min] = generation[j];
									for(size_t k= 0; k < filter; k++)
										if(grade[k] < grade[min])min = k;
								}
								else
									delete [] generation[j];
							}
							if(curdata != &data) delete curdata;
							curdata = new stats;
							curdata->analyze(generation, filter);
							for(size_t j = 0; j < filter; j++) delete [] generation[j];
							delete [] generation;
							delete [] grade;
						}
					break;
					default:
						goto prterr;
					break;
				}
			}
			else{
prterr:
				printf("%s: invalid option \"%s\"\n", argv[0], argv[i]);
				return 2;
			}
		}
	srand(time(NULL));
	
	
	if(!data.cnames){
		FILE* f = fopen(NAMEDEF, "r");
		if(!f){
			fprintf(stderr, "%s: error opening file NAMEDEF: no such file\n", argv[0]);
			return 1;
		}
		char **names;
		size_t n = loadcsv(f, &names);
		fclose(f);
		data.analyze(names, n);
	}
	for(size_t i = 0; i < count; ++i)
		printf("%s\n", curdata->assemble());
	if(generations) delete curdata;
	if(!count)
	return 0;
}
