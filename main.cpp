#include <cstdio>
#include <cstdlib> 
#include <ctime>
#include <cmath>
#include <climits>

#include "rnamegen.h"

#define SEPARATOR ','
#define NAMEDEF "data/names.csv"

size_t loadcsv(FILE* f, char ***values){
	rewind(f);
	int inp, n = 1;
	enum{
		SEEK, // searching through the word for the comma
		SPAC  // searching through the spaces for the start of the word
	}state = SPAC;
	//obtaining an calculating the size of the file
	fseek(f, 0, SEEK_END);
	size_t fsize = ftell(f);
	fseek(f, 0, SEEK_SET);
	fsize -= ftell(f);
	char *buffer = new char[fsize];
	for(size_t i = 0; i < fsize; i++){
		buffer[i]=fgetc(f);
		if(buffer[i] == ',')n++; // increment N if we come by a comma
	}
	*values = new char*[n];
	size_t ival = 0;
	for(size_t i = 0; i < fsize; i++){
		switch(state){
			case SEEK:
				if(buffer[i] == ',' || buffer[i] == '\n'){
					state = SPAC;
					buffer[i] = '\0';
				}
			break;
			case SPAC:
				if(buffer[i] != ' ' && buffer[i] != '\n'){
					//NOTE: this may break if multiple immediatelly successive commas are present
					state = SEEK;
					(*values)[ival++] = &buffer[i];
				}
			break;
		}
	}
	return n;
}

//TODO: implement functions to load and save letter data in a file, as well as reimplement the analyzer function in order to make it possible for it to take the existing letter data, and append to it
int main(int argc, char *argv[]){
	stats data, *evodata = &data;
	//default values, modified by the user
	size_t count = 1;
	size_t generations = 0;
	size_t gensize = 10000;
	size_t filter = 1000;
	bool append_to_base = false;
	
	if(argc > 1)
		for(int i = 1; i < argc; i++){
			size_t l;
			for(l = 0; argv[i][l]; ++l);
			if(l == 2 && argv[i][0] == '-'){
				switch(argv[i][1]){
					case 'f':{ // which csv file to use for sampling names
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						FILE *f = fopen(argv[++i], "r");
						char **names;
						size_t n = loadcsv(f, &names);
						fclose(f);
						evodata->analyze(names, n);
						delete [] *names;
					}
					break;
					case 'n': // number of names to produce 
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						count = atoi(argv[++i]);
					break;
					case 'i':{ // input file to use
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						FILE *f = fopen(argv[++i], "r");
						char **csvalues;
						size_t n = loadcsv(f, &csvalues);
						fclose(f);

						if(n != UCHAR_MAX + 2 * UCHAR_MAX * UCHAR_MAX + 2){
							// we are expecting to read exactly char max value + 2 * charmax^2 + 2 numeric values
							// because for each character we store the weight of the
							// character itself, plus preceeding and succeeding values for each other character
							// and plus 2 to store the total word and letter count

							// loading any other amount is a sign of error!
							fprintf(stderr, "error loading the file: invalid number of values\nare you sure this is the input file generated by -o?\n");
							return 2;
						}
						size_t di = 0;
						for(size_t i = 0; i < UCHAR_MAX; i++){
							evodata->ldata[i].weight += atoi(csvalues[di++]);
								for(size_t j = 0; j < UCHAR_MAX; j++)
									evodata->ldata[i].preceede[j] += atoi(csvalues[di++]);
								for(size_t j = 0; j < UCHAR_MAX; j++)
									evodata->ldata[i].succeede[j] += atoi(csvalues[di++]);
						}
						evodata->ltotal += atoi(csvalues[di++]);
						evodata->cnames += atoi(csvalues[di++]);
						delete [] *csvalues;
					}
					break;
					case 'o':{ // output file to write to
						count = 0;
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0], argv[i]);
							return 1;
						}
						FILE *outfile = fopen(argv[++i], "w");
						for(size_t i = 0; i < UCHAR_MAX; i++){
							fprintf(outfile, "%ld,", evodata->ldata[i].weight);
							for(size_t j = 0; j < UCHAR_MAX; j++)
								fprintf(outfile, "%ld,", evodata->ldata[i].preceede[j]);
							for(size_t j = 0; j < UCHAR_MAX; j++)
								fprintf(outfile, "%ld,", evodata->ldata[i].succeede[j]);
						}
						fprintf(outfile, "%ld,%ld", evodata->ltotal, data.cnames);
					}
					break;
					case 'b': // generation batch size 
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						gensize = atoi(argv[++i]);
					break;
					case 's': // number of names to select for next gen
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0],argv[i]);
							return 1;
						}
						filter = atoi(argv[++i]);
					break;
					case 'g': // number of evaluative generations to produce
						if(argc == i - 1){
							printf("%s: option %s expects an argument\n", argv[0], argv[i]);
							return 1;
						}
						generations = atoi(argv[++i]);
						if(!data.cnames){
							FILE* f = fopen(NAMEDEF, "r");
							char **names;
							size_t n = loadcsv(f, &names);
							fclose(f);
							data.analyze(names, n);
						}
						for(size_t i = 0; i < generations; i++){
							char *generation[gensize];
							double grade[gensize];
					//		printf("generating generation %d\n", i+1);
							for(size_t j = 0; j < gensize; j++){
								generation[j] = evodata->assemble();
								grade[j] = data.evaluate(generation[j]);
							}
					//		printf("filtering generation %d\n", i+1);
							size_t min = 0;
							for(size_t k= 0; k < filter; k++)
								if(grade[k] < grade[min])min = k;
							for(size_t j = filter; j < gensize; j++){
								if(grade[j] > grade[min]){
									grade[min] = grade[j];
									delete [] generation[min];
									generation[min] = generation[j];
									for(size_t k= 0; k < filter; k++)
										if(grade[k] < grade[min])min = k;
								}
								else
									delete [] generation[j];
							}
							if(!evodata) delete evodata;
							evodata = new stats;
							evodata->analyze(generation, filter);
						}
					break;
					default:
						goto prterr;
					break;
				}
			}
			else{
prterr:
				printf("%s: invalid option \"%s\"\n", argv[0], argv[i]);
				return 2;
			}
		}
	srand(time(NULL));
	
	
	if(!data.cnames){
		FILE* f = fopen(NAMEDEF, "r");
		char **names;
		size_t n = loadcsv(f, &names);
		fclose(f);
		data.analyze(names, n);
	}
	for(size_t i = 0; i < count; ++i)
		printf("%s\n", evodata->assemble());
	if(generations) delete evodata;
	if(!count)
	return 0;
}
